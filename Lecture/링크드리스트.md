### 어레이

배열은 크기가 정해진 데이터의 공간입니다. 한 번 정해지면 바꿀 수 없어요!

배열은 각 호텔방(원소)에 즉시 접근할 수 있습니다 rooms[0] 처럼요! 여기서, 원소의 순서는 0부터 시작하고 이를 인덱스라고 부릅니다.

이 때, 즉시 접근 가능하다는 말은 상수 시간 내에 접근할 수 있음을 의미합니다. 즉,  O(1) 내에 접근할 수 있다고 말하곤 합니다.

> 배열은 원소를 중간에 삽입/삭제 하려면 모든 원소를 다 옮겨야 합니다. 

최악의 경우 배열의 길이 N 만큼을 옮겨야 하므로 O(N)의 시간 복잡도를 가집니다.

원소를 새로 추가하려면, 새로운 공간을 할당해야 하므로 매우 비효율적인 자료구조입니다.

### 링크드리스트

Ex) 화물칸 , 각 화물칸은 다음 칸을 연결짓는 연결고리로 이어져 있습니다!

```python
train_compartments = ["기관실"] -> ["시멘트"] -> ["자갈"] -> ["밀가루"] -> ["우편"]
```

여기서 어레이와 다르게 중간에 칸을 추가할 수도 뺼 수 도 있다.

리스트는 크기가 정해지지 않은 데이터의 공간입니다. 연결 고리로 이어주기만 하면, 자유자재로 늘어날 수 있습니다!

리스트는 특정 원소에 접근하려면 연결 고리를 따라 탐색해야 합니다.최악의 경우에는 모든 화물 칸을 탐색해야 하므로 O(N)의 시간 복잡도를 가집니다.

여기서, 앞으로 연결 고리를 포인터라 부르고, 각 화물 칸을 노드라고 부르겠습니다.

리스트는 원소를 중간에 삽입/삭제 하기 위해서는 앞 뒤의 포인터만 변경하면 됩니다. 

따라서 원소 삽입/삭제를 O(1)(상수시간 내)의 시간 복잡도 안에 할 수 있습니다.

---


![image](https://user-images.githubusercontent.com/78454649/145222719-58c88982-ace9-4561-9a1c-c12c1341e53d.png)

- Array 

특성 원소 조회 : 상수시간 내에 찾기 가능

중간에 삽입 삭제 : 전부 데이터를 땅기거나 밀거나 해야하기 때문에 o(n)의 시간복잡도를 가짐

데이터 추가 : 데이터 추가 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당받아야 한다 , 비효율적

> 데이터에 접근하는 경우가 빈번하다면 Array를 사용하자

- LinkedList 

특성 원소 조회 : 각 원소를 찾으려 탐색해야 하기 때문에 O(n)

중간에 삽입 삭제 : 단순 포인트만 변경하면 되기 때문에 상수시간 내에 가능

데이터 추가 : 모든 공간이 다 찼어도 맨 뒤의 노드만 동적으로 추가하면 된다.

> 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다.












