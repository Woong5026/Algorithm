### DP(Dynamic Programming)

DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)은 기본적인 아이디어로 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 

그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.

### 피보나치 수열 

피보나치 수열은 제2항까지는 1, 제3항부터는 바로 앞의 두 항을 더한 수로 정의됩니다. 제0항은 생략하기도 합니다.

```python

(0), 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...

```

아래는 피보나치 수열의 n번째 수를 구하는 함수입니다.

```python

int fibo(int n)
  {
    if (n<=2)
      return 1;
    else
      return fibo(n-1) + fibo(n-2);
   }

```

하지만 이러한 피보나치를 쓰게 되면 

![image](https://user-images.githubusercontent.com/78454649/145767085-5b915cc0-4ff4-4e14-bb3a-143807f5c819.png)

처럼 15를 계산하기 위해 14 와 13 이 쓰였는데 13의 경우 이미 14를 구할때 썼었고 이는 12에도 해당되며 

다시 진행되는 것을 볼 수 있다, 이미 진행되었던 것임에도 불구하고 말이다

> 호출되는 함수의 횟수는 기하급수 적으로 증가된다는 문제점

---

위의 예시처럼 이미 했던 연산이 반복되는 결점을 보완하기 위해서 동적 계획법(Dynamic Programing, DP)이 고안되었습니다. 

원리는 간단합니다. 처음 진행되는 연산은 기록해 두고, 이미 진행했던 연산이라면 다시 연산하는 것이 아니라 **기록되어 있는 값을 가져오는 것**이죠.

### 다이나믹 프로그래밍 사용 조건

- 사용을 위한 가정

1. 큰 문제를 작은 문제로 나눌 수 있다(15를 구하기 위해 14, 13 번째를 나눈 것처럼) , 즉 큰 문제는 작은 문제와 동일한 형태를 가지고 있다

2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다(핵심적)
 
작은 문제에서 구한 값을 저장해두고 큰 문제에서 다시 사용한다 

### 메모지네이션 

동일한 문제를 반복해야 할 경우, 한 번 계산된 결과를 저장해 두었다가 활용하는 방식으로 

중복 계산을 줄이는 것을 메모이제이션(Memoization)이라고 합니다.


### TOP-DOWN

dp[n]의 값을 찾기 위해 위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 후 재활용하는 방식이다.

이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 

그래서 가장 최근의 상태 값을 메모해 두었다고 하여 Memoization 이라고 부른다.

```python

int fiboData[100] = {0,};

int fibo(int n)
{
  if (n<=2) 
    return 1;
  if (fiboData[n]==0)
    fiboData[n] = fibo(n-1) + fibo(n-2);
  return fiboData[n];
}

```

### Bottom-Up 

dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. 

Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

```python

int fibo(int n)
{
  fibodata[0] = 0;
  fiboData[1] = 1;
  for (int i=2; i<=n; i++)
    fiboData[i] = fiboData[i - 1] + fiboData[i - 2];
  return fiboData[n];
}

```

